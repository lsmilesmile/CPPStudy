# 处理数据

> author: liuxiao
>
> date:     2022.1.7



## 前言

1. 内置C++类型
   - 基本类型
     - 整数
     - 浮点数
   - 复合类型
     - 数组
     - 字符串
     - 指针
     - 结构



## 简单变量

声明一个变量：

```c++
int a;
a = 1;
```

程序中使用这个整数，并且该整数使用名称a来表示其值。过程：程序找到一块存储整数的内存，将该内存单元标记为a，并将1复制到该内存单元中，后面就可以通过a来访问该内存单元。如果要知道内存地址，可以使用**&**来检索该内存单元的地址。&a。



### 变量名

C++基本的命名规则

- 在名称中只能使用字母字符、数字和下划线（_）;
- 名称的第一个字符不能是数字；
- 区分大写字符与小写字符；
- 不能将c++关键字用作名称；



### 整形

没有小数部分的数字，如1， 2， -1， 0。

c++基本整型：

- char
- short
- int
- long
- long long(c++11)



### 整型short、int、long、long long

这几种整型的最小长度

- short至少16位
- int至少和short一样长
- long至少32位，且至少与int一样长；
- long long至少64位，且至少和long一样长。

检查类型或变量的长度：**sizeof**运算符,单位是字节。

1. C++11初始化

   ```c++
   int a{1};
   int b = {2};
   int c = {}; //初始化为0
   int d{};
   ```



### 无符号类型

- unsigned short
- unsigned int
- unsigned (also unsigned int)
- unsigned long
- unsigned long long



## c++确定常量的类型

类似

```c++
std::cout << "Year = " << 1995 << "\n";
```

除非有理由存储为其他类型（如使用特殊后缀，值太大，不能存储为int），否则都将整型常量存储为int类型。

后缀：

- l或L - long
- u或U - unsigned int
- ul - unsigned long
- ull、Ull、uLL、ULL - unsigned long long



### char类型：字符和小整数

- char类型能够表示目标计算机系统中的所有基本符号。虽然是用来表示字符的，但是可以将它用作比short更小的整型。

- char在默认情况下既不是没有符号，也不是有符号。可以根据开发需要将类型设置为signed char或unsigned char。

- **wchar_t**:

  程序需要处理的字符集无法用一个8位的字节表示，如日文汉字。方法一：编译器厂商将char定义为一个16位的字节或更长；方法二：wchar_t(宽字符类型)，可以表示扩展字符集。wchar_t是一种整型类型，可以表示系统使用的最大字符集。cin和cout将输入和输出看作是char流，不适合处理wchar_t类型。iostream头文件提供相似工具-wcin和wcout,可用于处理wchar_t流。可以通过前缀L来宽字符常量和宽字符串。

  ```c++
  wchar_t b = L'P';
  wcout << L"tall" << endl;
  ```

  

- **c++11新增类型：char16_t和char32_t**

  char16_t：无符号，长16位,，使用前缀**u**表示char16_t

  ```c++
  char16_t c = u'c';
  ```

  char32_t：无符号，长32位，使用**U**表示char32_t

  ```c++
  U'R';
  U'dir';
  ```



## bool类型

```c++
bool flag = false;
// 隐式转换
int a = true;
int b = false;
bool c = 0;
bool d = 1;
```



## const限定符

符号常量预处理方法：**#define**

c++处理符号常量：**const**

```c++
const int Months = 12; // 不能修改了
```

通用格式：const type name = value;

应该在声明中对const进行初始化。

好处：

- 明确指定类型
- 用作用域规则将定义限制在特定的函数或文件中；
- 将const用于更复杂的类型。



## 浮点数

浮点数是c++的第二组基本类型。

### 书写浮点数

- 第一种方法

  0.09

  12.2

  6.0

- 第二种：E表示法

  2.5e+8

  7E5

  1.2e-12

### 浮点类型

- float                - 至少32位
- double           - 至少48位
- long double  - 至少和double一样

### 浮点常量

程序默认情况将浮点常量存储为double类型。，如果希望是float类型：

1.2f

2.3E10f

2.1L // long double



## 算术运算符

- +
- -
- *
- /   - 两个数都是整数，则结果为商的整数部分
- % - 余数 

### 类型转换

- 将一种算术类型的值赋给另一种算术类型的变量时，c++将对值进行转换；
- 表达式包含不同的类型时，将进行转换；
- 将参数传递给函数时，对值进行转换；

#### 转换规则

1. **初始化和赋值进行的转换**

   c++允许将一种类型的值赋值给另一种类型的变量。这样的话，值将被转换为接受变量的类型。

2. **以{}方式初始化时进行的转换(c++11)**

   c++将使用大括号的初始化称为列表初始化，这种初始化常用于给复杂的数据类型提供值列表。该种转换比较严格，不允许缩窄。不允许将浮点型转换为整型。

3. **表达式中的转换**

   当一种表达式包含两种算术类型：1、一些类型在出现时会**自动转换**；2、有些类型在和其他类型同时出现在表达式中时将被转换。

   **自动转换**：C++将bool、char、unsigned char、signed char、和short值转换为int。

   ```c++
   short a = 1;
   short b = 2;
   short c = a + b; // 程序将a,b转换为int,再将结果转换为short赋值给c
   ```

   将不同的类型进行算术运算时，也会进行转换，如将int和float相加。运算涉及两种类型，较小的类型将被住转换为较大的类型。

   c++通过校验表来确定算术表达式中执行的转换:

   - 如果有一个操作上类型是long double，则将另一个操作数转换为long double。
   - 否则，如果有一个操作上是double，则将另一个操作数转换为double。
   - 否则，如果有一个操作数是float，则将另一个操作数转换为float。
   - 否则说明操作数都是整型，因此执行整型提升。
   - 在这种情况下，如果两个操作数都是有符号或者无符号的，且其中一个操作数比另一个级别低，则转换为级别高的类型。
   - 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号的操作数级别比有符号的操作数高，则将有符号操作数转换为无符号操作数所属的类型。f
   - 否则，如果有符号类型可以表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。
   - 否则，将两个操作数都转换为有符号类型的无符号版本。

4. **传递参数时的转换**

   传递参数时的类型转换由c++函数原型控制。也可以取消原型对参数传递的控制，在这种情况下，c++将char和short类型(signed和unsigned)应用整型提升。在将参数传递给取消原型对参数传递控制的函数时，c++将float提升为double。

5. **强制类型转换**

   - 将存储在thorn中的int值转换为long类型；强制类型转换不会修改thorn本身，而是创建一个新的、指定类型的值。

     ```c++
     (long)thorn; // (typename)value c
     long(thorn); // typename(value) c++
     ```

     

   - 4个强制类型转换运算符

     后面介绍。**static_cast<>**可用于将值从一种数值类型转换为另一种数值类型

     static_cast\<long\>(thorn)

     static_cast\<typeName\>(value)

6. **C++11中的auto声明(auto是关键字)**

   让编译器能够根据初始值的类型推断变量的了类型。auto一般用来处理复杂的类型，如：

   c++98:

   ```c++
   std::vector<double> scores;
   std::vector<double>::iterator pv = scores.begin();
   ```

   c++11:

   ```c++
   std::vector<double> scores;
   auto pv = scores.begin();
   ```

   

 